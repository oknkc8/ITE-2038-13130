!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CC	Makefile	/^CC=gcc$/;"	m
DEFAULT_ORDER	include/bpt.h	17;"	d
HEADERPAGENUM	include/file_manager.h	6;"	d
INC	Makefile	/^INC=include\/$/;"	m
LIBS	Makefile	/^LIBS=lib\/$/;"	m
LICENSE_CONDITIONS	include/bpt.h	29;"	d
LICENSE_CONDITIONS_END	include/bpt.h	31;"	d
LICENSE_CONDITIONS_START	include/bpt.h	30;"	d
LICENSE_FILE	include/bpt.h	25;"	d
LICENSE_WARRANTEE	include/bpt.h	26;"	d
LICENSE_WARRANTEE_END	include/bpt.h	28;"	d
LICENSE_WARRANTEE_START	include/bpt.h	27;"	d
MAX_ORDER	include/bpt.h	22;"	d
MIN_ORDER	include/bpt.h	21;"	d
OBJS_FOR_LIB	Makefile	/^OBJS_FOR_LIB:=$(SRCS_FOR_LIB:.c=.o)$/;"	m
PAGESIZE	include/page_structure.h	4;"	d
ROOTPAGENUM	include/file_manager.h	7;"	d
SRCDIR	Makefile	/^SRCDIR=src\/$/;"	m
SRCS_FOR_LIB	Makefile	/^SRCS_FOR_LIB:=$(SRCDIR)bpt.c $(SRCDIR)file_manager.c$/;"	m
TARGET	Makefile	/^TARGET=main$/;"	m
TARGET_OBJ	Makefile	/^TARGET_OBJ:=$(SRCDIR)main.o$/;"	m
TARGET_SRC	Makefile	/^TARGET_SRC:=$(SRCDIR)main.c$/;"	m
Version	src/bpt.c	4;"	d	file:
__BPT_H__	include/bpt.h	2;"	d
__FILE_MANANGER_H__	include/file_manager.h	2;"	d
__PAGE_STRUCTURE_H__	include/page_structure.h	2;"	d
adjust_root	src/bpt.c	/^void adjust_root(void) {$/;"	f
bool	include/bpt.h	11;"	d
branch_factor_t	include/page_structure.h	/^typedef struct branch_factor_t{$/;"	s
branch_factor_t	include/page_structure.h	/^} branch_factor_t;$/;"	t	typeref:struct:branch_factor_t
child_page_offset_num	include/page_structure.h	/^    pagenum_t child_page_offset_num;$/;"	m	struct:branch_factor_t
cut	src/bpt.c	/^int cut( int length ) {$/;"	f
db_fd	include/file_manager.h	/^int db_fd;$/;"	v
delete	src/bpt.c	/^int delete(int64_t key) {$/;"	f
delete_entry	src/bpt.c	/^void delete_entry( page_t * n, pagenum_t n_pagenum, int64_t key, $/;"	f
dequeue	src/bpt.c	/^pagenum_t dequeue( void ){$/;"	f
enqueue	src/bpt.c	/^void enqueue( pagenum_t new_pagenum ) {$/;"	f
entries	include/page_structure.h	/^        branch_factor_t entries[248];$/;"	m	union:page_t::__anon1
false	include/bpt.h	12;"	d
file_alloc_page	src/file_manager.c	/^pagenum_t file_alloc_page(){$/;"	f
file_free_page	src/file_manager.c	/^void file_free_page(pagenum_t pagenum){$/;"	f
file_read_page	src/file_manager.c	/^void file_read_page(pagenum_t pagenum, page_t* dest){$/;"	f
file_write_page	src/file_manager.c	/^void file_write_page(pagenum_t pagenum, const page_t* src){$/;"	f
find	src/bpt.c	/^char * find( int64_t key ) {$/;"	f
find_and_print	src/bpt.c	/^void find_and_print( int64_t key, bool is_p ) {$/;"	f
find_leaf	src/bpt.c	/^page_t * find_leaf( int64_t key, pagenum_t * index) {$/;"	f
free_page_offset_num	include/page_structure.h	/^    pagenum_t free_page_offset_num;$/;"	m	struct:header_page_t
get_left_index	src/bpt.c	/^int get_left_index( page_t * parent, pagenum_t left_pagenum) {$/;"	f
get_neighbor_index	src/bpt.c	/^pagenum_t get_neighbor_index( page_t * n, pagenum_t n_pagenum, bool * is_most_left ,$/;"	f
header_page	include/file_manager.h	/^header_page_t * header_page;$/;"	v
header_page_t	include/page_structure.h	/^typedef struct header_page_t{$/;"	s
header_page_t	include/page_structure.h	/^} header_page_t;$/;"	t	typeref:struct:header_page_t
insert	src/bpt.c	/^int insert ( int64_t key, char * value ) {$/;"	f
insert_into_leaf	src/bpt.c	/^void insert_into_leaf( page_t * leaf, record_t * record ) {$/;"	f
insert_into_leaf_after_splitting	src/bpt.c	/^void insert_into_leaf_after_splitting( page_t * leaf, record_t * record, pagenum_t pagenum ) {$/;"	f
insert_into_new_root	src/bpt.c	/^void insert_into_new_root(page_t * left, pagenum_t * left_pagenum, int64_t key, $/;"	f
insert_into_node	src/bpt.c	/^void insert_into_node( page_t * n, pagenum_t n_pagenum, int left_index, $/;"	f
insert_into_node_after_splitting	src/bpt.c	/^void insert_into_node_after_splitting( page_t * old_page, pagenum_t * old_page_pagenum, int left_index, $/;"	f
insert_into_parent	src/bpt.c	/^void insert_into_parent(page_t * left, pagenum_t * left_pagenum, int64_t key, $/;"	f
is_leaf	include/page_structure.h	/^    int is_leaf;$/;"	m	struct:page_t
key	include/bpt.h	/^int delete(int64_t key);$/;"	v
key	include/page_structure.h	/^    int64_t key;$/;"	m	struct:branch_factor_t
key	include/page_structure.h	/^    int64_t key;$/;"	m	struct:record_t
license_notice	src/bpt.c	/^void license_notice( void ) {$/;"	f
main	src/main.c	/^int main( int argc, char ** argv ) {$/;"	f
make_leaf	src/bpt.c	/^page_t * make_leaf( void ) {$/;"	f
make_node	src/bpt.c	/^page_t * make_node( void ) {$/;"	f
make_record	src/bpt.c	/^record_t * make_record( int64_t key, char * value ) {$/;"	f
next	include/bpt.h	/^    struct queue_node * next;$/;"	m	struct:queue_node	typeref:struct:queue_node::queue_node
num	include/bpt.h	/^    pagenum_t num;$/;"	m	struct:queue_node
num_keys	include/page_structure.h	/^    int num_keys;$/;"	m	struct:page_t
num_pages	include/page_structure.h	/^    int64_t num_pages;$/;"	m	struct:header_page_t
open_db	src/file_manager.c	/^int open_db(char* pathname){$/;"	f
order	src/bpt.c	/^int order = DEFAULT_ORDER;$/;"	v
page_t	include/page_structure.h	/^typedef struct page_t{$/;"	s
page_t	include/page_structure.h	/^} page_t;$/;"	t	typeref:struct:page_t
pagenum_t	include/page_structure.h	/^typedef uint64_t pagenum_t; $/;"	t
parent_page_offset_num	include/page_structure.h	/^	pagenum_t parent_page_offset_num;	\/\/ if parent_page_offset_num is 0, this page is root$/;"	m	struct:page_t
path_to_root	src/bpt.c	/^int path_to_root( pagenum_t child_pagenum ) {$/;"	f
pointer_num	include/page_structure.h	/^    pagenum_t pointer_num;$/;"	m	struct:page_t
print_free_page_list	src/bpt.c	/^void print_free_page_list(){$/;"	f
print_leaves	src/bpt.c	/^void print_leaves( void ) {$/;"	f
print_license	src/bpt.c	/^void print_license( int license_part ) {$/;"	f
print_tree	src/bpt.c	/^void print_tree( void ) {$/;"	f
queue	src/bpt.c	/^queue_node * queue = NULL;$/;"	v
queue_node	include/bpt.h	/^typedef struct queue_node{$/;"	s
queue_node	include/bpt.h	/^} queue_node;$/;"	t	typeref:struct:queue_node
record	include/bpt.h	/^typedef struct record {$/;"	s
record	include/bpt.h	/^} record;$/;"	t	typeref:struct:record
record_t	include/page_structure.h	/^typedef struct record_t{$/;"	s
record_t	include/page_structure.h	/^} record_t;$/;"	t	typeref:struct:record_t
records	include/page_structure.h	/^        record_t records[31];$/;"	m	union:page_t::__anon1
redistribute_nodes	src/bpt.c	/^void redistribute_nodes( page_t * n, pagenum_t n_pagenum, page_t * neighbor,$/;"	f
remove_entry_from_node	src/bpt.c	/^page_t * remove_entry_from_node( page_t * n, pagenum_t n_pagenum, int64_t key ) {$/;"	f
reserved	include/page_structure.h	/^    char reserved[104];$/;"	m	struct:page_t
reserved	include/page_structure.h	/^    char reserved[4072];$/;"	m	struct:header_page_t
root_page	include/file_manager.h	/^page_t * root_page;$/;"	v
root_page_offset_num	include/page_structure.h	/^    pagenum_t root_page_offset_num;$/;"	m	struct:header_page_t
start_new_tree	src/bpt.c	/^void start_new_tree( record_t * record ) {$/;"	f
true	include/bpt.h	13;"	d
usage_1	src/bpt.c	/^void usage_1( void ) {$/;"	f
usage_2	src/bpt.c	/^void usage_2( void ) {$/;"	f
usage_3	src/bpt.c	/^void usage_3( void ) {$/;"	f
value	include/bpt.h	/^    int value;$/;"	m	struct:record
value	include/page_structure.h	/^    char value[120];$/;"	m	struct:record_t
verbose	src/bpt.c	/^bool verbose = false;$/;"	v
